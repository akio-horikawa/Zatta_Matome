# JavaScript_学習メモ

---

このメモは、 __JavaScript__ を学習するために、1~10までをマメに記述する予定のメモ。三日坊主で終わらないことを切に願っている。因みに学習用に教本として【オライリージャパン】の【JavaScript_第7版】 __（税込5,060円）__ を使用している。本当に三日坊主で終わらないようにしないと後悔することになる。
（追記）多少なり飛ばしている部分もあるので、不明点は都度調査すべき。

---

## 目次 <a id = mokuji></a>
[１章 JavaScript概要](#1)  
[２章 字句構造](#2)  
[３章 型・値・変数](#3)  
[４章 式と演算子](#4)  
[５章 文](#5)  
[６章 オブジェクト](#6)  
[７章 配列](#7)  
[８章 関数](#8)  

---

<a id = 1></a>
## １章 JavaScript概要

JavaScriptとは、Webのためのプログラミング言語。ほぼ全てのWebサイトで使用されていて、スマホ等の最新ブラウザにおいても全てにJavaScriptインタプリタが搭載されている。

→　**インタプリタ**　：　通訳者。Compでプログラムを処理する方法の一つ。実行時にソースコードを一行ずつ機械語に変換するのが特徴。

JavaScriptはJavaと名前が似ているが両者は全く違う言語であり、似ているのは名前のみである。最初こそスクリプトとして実装されたJavaScriptは現在では大規模ソフトウェアを作成する際にまで利用されている。

全ての言語には負担軽減のためのプラットフォームや標準ライブラリが含まれているが、コアJavaScript言語には最小限のAPIのみが定義されている。ホスト環境で提供される前提のため、入出力機能は含まれていない。Web上でのJavaScriptのコードはユーザーのマウスやキーボードからの入力、Webサーバからの情報の受け取りを行うことができる。

私個人としては、Webシステムのためだけでなく、JavaScriptという言語の基礎的な、基本的な仕様等に注目して学んでいきたい。

#### いつもの

ブラウザで開発者ツールなどからコンソールを開く他、Node.js等を導入してターミナルからJavaScriptの簡単なコードを試すことができる。 `console.log("Hello World!")` を動作させてみれば、見慣れた表示がコンソールで確認できるはず。

*Hello World!* ――― いつもの

[1章 JavaScript概要](#1)  
[目次](#mokuji)  

---

<a id = 2></a>
## ２章 字句構造

JavaScriptは大文字小文字を区別する。変数や関数名、識別子では厳密に区別されるために気を付ける必要がある。トークンを区切る空白の他、一般的に改行を無視するため、プログラム内では自由に空白と改行を使用可能である。

→　**トークン**　：　証拠。ソースコード上でそれ以上分割できない最小単位の文字列。

##### コメント

コメントは `//ここにコメント` や `/* ここにコメント */` のように記述する他、 `// => 値 or "値" :ここにコメント` のように記述することでアサーションとして機能し、コードの検証に利用することが可能。（それとは別に検証用のコードが必要になる）

→　**アサーション**　：　自己主張。プログラミングにおいて、あるコードが実行される時に満たされるべき条件を記述して実行時にチェックする仕組みのこと。

アサーション用のコメント記法には他に `//a == 値` 、 `// !例外` のようなものも存在する。

##### 識別子

識別子は変数や関数、クラスに付けられる名前のこと。先頭は数字以外でなければならず、予約語である元々設定されている語句を使用することはできない。

##### 予約語

予約語はJavaScript言語の一部として使用されているため変数やクラスの名前として使用することは不可である。 `from` 、 `of` 、 `get` 、 `set` 等は、予約語として使用される場面が少ない上に、識別子として使用されやすいものなので利用すべき。以下は予約語の例。

```
as async await break case catch class const continue 
debugger default delete do else export extends false 
finally for (from) function (get) if import in instanceof 
let new null (of) return (set) static super switch target
this throw true try typeof var void while with yield
//以下は将来的に予約語とされている。
enum implements interface package private protected public
```

また、特殊な理由で特定状況下では `arguments` と `eval` は識別子として利用不可のため、普段から仕様は避けるべきである。

##### Unicode

JavaScriptはUnicode文字コードを使用して、文字列やコメントを記述できる。しかし、識別子に関してはASCII文字か数字を使用するのが一般的となっている。慣習なので気にせずUnicodeを識別子として使用することは可能。

##### エスケープシーケンス

エスケープシーケンスとは、Unicodeを表現するために並べられたASCII文字の並びのこと。全ての環境でUnicodeが表示できるわけではないために、 `\u` で始まり、後ろに4文字の16進数を記述する。その他、中括弧内で1~6文字の16進数を記述することで表せる。コメント内にもエスケープシーケンスを記述できるが、単にASCII文字として扱われるだけでUnicode文字として解釈されることはない。

##### Unicode正規化

JavaScriptではUnicodeの正規化処理は行わないため、Unicode文字を使用する場合はエディタ等で正規化を行うと見た目は同じでも実際にはデータが違うような識別子に悩まされなくなる。

##### 省略可能セミコロン

JavaScriptでは文末のセミコロンは省略可能。しかし、文の終端を示すものなので有って悪い事はない。セミコロンがない場合は改行を終端と解釈するが、括弧などで文が始まった時、前の文章の続きだと解釈されてしまう場合があるため、中々良くない状況になる。これを避けるために文の最初にセミコロンを記述する人もいる。その他にも、 `++` や `=>` 等は一つの文で表した方が良い。

[2章 字句構造](#2)  
[目次](#mokuji)  

---

<a id = 3></a>
## ３章 型・値・変数

##### 型

JavaScriptの型には基本型とオブジェクト型が存在する。基本型には数値や文字列、論理値がある。また、JavaScriptの特殊な値である `null` や `undefined` も基本型の値である。それ以外の値がオブジェクト、プロパティの集合体である。

→　**プロパティ**　：　属性。オブジェクトの状態や属性のことをいう。

##### 数値

JavaScriptにおいて数値型は整数と大凡の実数を64ビット浮動小数で表す。プログラム内に直接記述される数字は数値リテラルと言い、全ての数値リテラルは前に `-` をつけることで符号を反転できる。

##### 整数リテラル

10進数は数字をただ並べるのみ。
`1000000`
16進数は先頭が 0x or 0X で後ろには16進数値が続く。
`0xff // => 255`

##### 浮動小数点リテラル

JavaScriptでは実数は浮動小数点リテラルを使用して表す。先頭を整数部、続いて小数点、小数部という形式である。指数は e or E の次に (+) or (-) 、次に整数指数という形式で小数部の後ろに記述することになる。

また、数値リテラル内ではアンダースコアが自由に使えるため、見やすさを重視するなら活用すべきである。

##### JavaScriptでの算術演算

JavaScriptの基本的算術演算子には、 **加算(+)、減算(-)、乗算(*)、除算(/)、剰余(%)、べき乗(\*\*)** が使用可能であり、より複雑なものはMathプロパティに定義されている。

JavaScriptでは演算中にオーバーフローやアンダーフローが起きてもエラーが発生しない。

→　**オーバーフロー**　：　上桁あふれ。結果が表現可能な最大値よりも大きくなってしまったこと。
→　**アンダーフロー**　：　下桁あふれ。結果が表現可能な最小値よりも0に近づいたときのこと。

JavaScriptでのオーバーフローは、正の値ならば無限大 `Infenity` 、負の値ならば負の無限大数値 `-Infenity` を返す。アンダーフローならば、 `負の0` という特殊な値を返す。 `負の0` は通常の0と区別しないため気にする必要はない。
0除算に関してもエラーは出ず `Infenity` 等が返されるが、0を0で割った時に関しては `NaN` が返される。これは不定を表し、他にも無限大を無限大で割った時や、負数の平方根を求めたとき、数値に変換できないオペランドに対して演算を行った場合にも出力されてしまう。

→　**オペランド**　：　被演算子。コンピュータ演算における値や変数。演算子によって演算の対象になるもの。

`NaN` はどの値とも等しく扱われない。 `x == NaN` は判定できず、正しい結果を得たいのなら `x != x` のような形で記述する必要がある。（ `Number.isNaN(x)`  でも良い）引数が `NaN` か数値に変換できないときに `true` が返される。同じように `Number.isFinite()` は `NaN` や無限大以外なら `true` を返してくれる。

##### 2進浮動小数点

JavaScriptでは実数の表現には限度があり、2進数表記のために1/2や1/8のような少数は正確に表現できるものの1/10など人にとって利用しやすいものに関しては非常に近い値を出力する。尚、十分な精度は確保されているため0.1をほぼ近似表現することは可能になっている。

##### BigIntによる任意精度整数

BigIntとは64ビット整数を表現するために導入されたもの。数字文字列の最後に小文字のnを記述して先頭には何も付けないと10進数を表現できる。先頭に0b、0o、0xを記述することでそれぞれが2進数、8進数、16進数を表現できる。 `BigInt()` を使うことで通常の値や文字列をBigIntの値に変換可能。演算に関しては通常のオペランドとの併用は出来ないので注意されたし。また、BigIntは大きな数（数千桁）を表現できるもののタイミング攻撃に弱く、また整数しか表現できないという特徴がある。

→　**タイミング攻撃**　：　アルゴリズムの動作特性を利用したサイドチャネル攻撃。暗号処理のタイミングが暗号鍵の論理値により変化することを利用して暗号化や復号に要する時間から暗号鍵を推定するもの。
→　**サイドチャネル攻撃**　：　電子機器の物理量を観測することで内部情報を取得する攻撃手法。

##### 日付・時刻

JavaScriptでは、日付や時刻を表現、操作するDateクラスが用意されている。
```
let timestamp = Date.now(); // 現在時刻（数値）
// ↑ 何に使うのかは謎
let now = new Date(); // 現在時刻のDateオブジェクト
let ms = now.getTime(); // ミリ秒単位のタイムスタンプ（数値）
// ↑ 何に使うのかは謎
let iso = now.toISOString(); // 標準形式の文字列に変換？
// ↑ Dateオブジェクトを文字列にするもの
```
<br>

##### テキスト

文字列はUnicode文字を表す16ビット値の並びの不変のデータ。16ビット値で収まらない位置のUnicode文字は2つの16ビット値（サロゲートペア）で表す。文字列は反復可能で `for` 等で実際の文字に対して反復処理を行える。

文字リテラルに関してはプログラム中で文字列を `''`  `""`  ` `` ` で囲むことで記述可能。それぞれを併用することもでき、文字列中に ` `` `を使用することでJavaScriptのコードを文字列に補完することも可能。

また、文字列を複数行に分けて記述する際は、 `\` を末尾に記述することでその直後の改行をリテラルに含まずに読み込むことができる。 ` `` ` で囲まれた中は改行が含まれていても分割可能。アポストロフィ等が文字列に含まれる場合も `\` でエスケープする必要がある。エスケープシーケンスは種類があるので都度確かめられたし。

JavaScriptでは `+` で文字列の加算が可能。また、 `==` `!==` を使用することで比較が可能である。文字列の長さの調査には `s.length` を使用する。 `length` プロパティ以外にも文字列を操作するAPIは存在しているが数が多いので都度調べられたし。

文字列が ` `` ` で囲めるようになったのはJavaScriptがES6になってから。これは、ただの文字列ではなく、テンプレートリテラルと呼ばれる。 `${ text }` このように囲まれたテキストは式として評価され文字列に変換されテンプレートリテラルに挿入される。また、最初のバッククォートの前に関数名（タグ）を付けるとテンプレートリテラル内のテキストや式は関数に渡され戻り値になる。HTMLやSQLのエスケープ等に利用できる。

##### 論理値

論理値は `true` `false` が返されるもの。 `a === 0` であればaが0ならば真となり、 `true` 違うのなら偽となって `false` を返す。主に制御構文で使われる。これに関しては他のプログラミング言語と大差ないだろう。

##### nullとundefined

JavaScriptの `null` は値が存在しないということ。 `null` に対してtypeof演算子（対象のデータ型を文字列で返すもの）を使用すれば "object" という値が返ってくる。つまりは、 `null` は __オブジェクトが存在しない__ ことを表すもの。他にも __値がない__ ことを表すときにも使用されるが、JavaScriptには  `undefined` がある。こちらは未定義を表すもので、値がない、存在しないことを表すが、こちらは初期化されていないものや宣言されていない値を指す。また、 `undefined` にtypeofを使うと `undefined` が返ってくる。

`null` `undefined` はどちらも値がないことを表し、プロパティやメソッドを持たず、 `==` では真となるが、（ `===` では区別可能）`undefined` のほうは主にエラーというか予期していない不具合やミスによって出力されることが多い。どちらか一方を使うような場合ならば `null` の方がいいかもしれない。

##### Symbol

SymbolはES6から追加された文字列ではないプロパティ名。一般的なプロパティは文字列ですがSymbolを使用できるようになったということ。Symbolにはリテラルが存在せず、 `Symbol()` で値を呼び出せば同じ値は二度返すことがない。同じ引数を渡したとしても、同じ値は返ってこない。利点としては同じプロパティ名を使用してしまい既存のものを上書きする心配がいらない点。

Symbolには文字列引数を渡すことができ、その場合は `toString()` で文字列引数の出力を得られる。

##### オブジェクト

グローバルオブジェクトとは、通常のJavaScriptオブジェクトだが、非常に重要なもの。システム起動時に生成され基本的なプロパティを生成し初期化する。デフォルトで使用できていた定数や関数もこれに含まれているのだから重要性はよく理解できる。

オブジェクトは基本型の値とはしっかりと違いがある。基本型が不変であり、値で比較する（文字列ならば同じ長さで各インデックスの文字が同じ場合には等しいと判定する）のに対し、オブジェクトは可変で、値をでは比較しない。オブジェクトは参照で比較すると言い、基本型に対して参照型と呼ぶこともある。同じオブジェクトを参照している時に等しいと判定する。
```
a = 0;
b = 0;
a === b; // => false

a = [];
b = a;
a === b; // => true
```
<br>

##### 型の変換

JavaScriptでは必要とする値の型について柔軟な対応をする。数値を文字列に、文字列の数の演算結果を数値に、また、数値に変換できない文字列を変換しようとすれば `NaN` を返してくれる。真偽の10変換よろしく基本型から基本型への変換はわかりやすく簡単だが、オブジェクト型が関わるとそうはいかない。また、明示的に変換をすることもできる。 `Boolean()` `Number()` `String()` 関数を想像すれば理解も容易い。

オブジェクトから基本型への変換はオブジェクトの種類によって変換規則が変わるため複雑化している。変換規則には優先する対象別に3つのアルゴリズムに分けられる。文字列優先、数値優先、それ以外（優先度無）である。最後の優先度無ではDate以外は文字列優先でそれ以外は数値優先が設定されている。 __ここで参考にしている本に誤字を見つけた。__

論理値への変換は単純で、すべてのオブジェクトは `true` に変換される。

文字列への変換は、まず基本型の値に変換してから必要があれば文字列に変換という流れなのだが、ここでも独自にルールが設定されている。
→ 理解出来次第追記

数値への変換は、文字列の変換と同じような流れで基本型の値に変換してから数値へという流れだが、文字列の変換とは違うルールで変換される。
→ 理解出来次第追記

##### 変数の宣言と代入

ようやっとここまで来た。
変数は識別子を付けることで区別できるようにして、利用するもの。値に名前を付けることは変数に値を代入すると言う。永続的な値の代入ならば変数というよりは定数という方が正しい。

JavaScriptでは現在、 `let` `const` を使用して変数の宣言を行う。2つの違いは再代入できるか否か。 `let` は再代入可なのでよく使用するイメージ。 `const` は再代入不可ということで宣言自体は少なくとも呼び出す回数は多いイメージ。他にも関数無や `var` があるがこれは扱いが難しいどころかミスの原因になり得るので使用は非推奨。（宣言した変数がグローバルスコープ化する等の特徴があるが、再宣言可能というとんでもない仕様。巻き上げされるという特徴も持ち、宣言のタイミングがズレにズレ、undefinedが多発する可能性あり）
ソースコード内の変数の有効範囲をスコープと言うが、 `let` `const` はブロックスコープと言って、それらがあるコードのブロック内で有効となる。ブロック外で宣言した時はグローバルスコープ、つまり全体で有効になる。となると本当に `var` の使いどころはわからない。

JavaScriptではCやJavaと違い型を指定する必要がない。とある変数に数値を代入した後に文字列を代入してもエラーにならない。
→ もちろんこんなことをしていいわけではない。（エラーが出ないだけ、大域変数になる上に再代入どころか再定義もできてしまう）

##### 分割代入

活用できれば配列を返すのが楽になる。見た方が早い。
```
let [x,y] = [1,2]; // x == 1, y == 2
[x,y] = [y,x]; // xとyが入れ替わる
[x,y]; // => [2,1]

let [a,b] = [1]; // => a == 1, b == undefined
[a,b] = [1,2,3]; // => a == 1, b == 2
[,a,,b] = [1,2,3,4]; // => a == 2, b == 4
// 配列からの分割代入時に使われていない値を纏めたい場合
[c, ...d] = [1,2,3,4]; // d == [2,3,4]
```
→ 追記の必要があるかもしれない。

[3章 型・値・変数](#3)  
[目次](#mokuji)  

---

<a id = 4></a>
## ４章 式と演算子

プログラムにおける式は、Javaインタプリタが評価し、値を生成できるもののこと。変数名も式の一種であり、評価されて変数に代入され値とみなされる。配列や関数呼び出しの式もまた同じようにオブジェクトになる式と引数として使われる式から構成されている。値の生成に値を組み合わせて行う場合は演算子が使用される。演算子が各値から新しい値を生成し返す。

##### 単項式

単純で他の要素を持たない式を単項式と呼ぶ。リテラル（定数値）やJavaScriptキーワード、変数参照等。これまで散々リテラルと呼んでいたものは `"hello!"` のような値単体のこと。

##### オブジェクト・配列の初期化子

新たに生成されるオブジェクトや配列の値になる式のことをそれらの初期化子という。オブジェクトリテラル、配列リテラルとも呼ばれる。他のリテラルと違い、単項式ではなく、要素の値をしているため複数の式で構成されている。

##### 関数定義式

その名の通り関数の定義をする式。オブジェクトリテラルのようにこちらも関数リテラルと呼ばれることがある。一般的に `function` に続いて要素を記述することで丸括弧内にブロックを記述する形になる。
```
let kansu = function(x) { return x * x };
```

##### プロパティアクセス式

オブジェクトプロパティの値や配列の要素を呼び出す式。式、ピリオド、識別子という順で書く。
```
const acc = {
    x : 1,
    y : {z : 2},
}
const a = [o, 3, [4, 5]];

acc.x; // => 1 : acc内のxの値
acc.y.z; // => 2 : acc内のy内のzの値
o["x"]; // => 1 : oの中のxの値
a[1]; // => 3 : aのインデックス1の要素
a[2]["1"]; // => 5 : a[2]のインデックス1の要素
a[0].x; // => 1 : a[0]のプロパティxの値を出力
```

どのプロパティ式を使おうともピリオドや括弧の前から評価される。また、評価された値が `Null` `undefined` ならば `TypeError` を返す。プロパティが存在しない場合は `undefined` を返す。

##### 条件付きプロパティアクセス

 `Null` `undefined` が返されたときにエラーが出てしまうことを防ぐため、 `?.` `?.[式]` の構文を使用する。オプショナルチェイニングとも呼ばれる。

 ##### 呼び出し式

 呼び出し式は関数やメソッドの実行のための構文。関数式の後に丸括弧、その中に引数式を記述する。

 呼び出しにも条件付き、つまり `?.()` のような形のエラー回避方法がある。

##### オブジェクト生成式

新たなオブジェクトの生成をするためコンストラクタと呼ばれる関数を呼び出し、オブジェクトのプロパティを初期化する。呼び出し式に近い形だが、 `new` で記述する違いがある。
```
new object();
new Object;
```
引数を渡さない場合は括弧は省略可。

##### 演算子

演算子は算術式や比較式、論理式、代入式で使用される。基本は記号だが、 `delete` `instanceof` のようなキーワードで表すものもある。

演算子はオペランドの数で大きく3つに分けられる。基本的な二つの式を組み合わせて算術する二項演算子、1つの式を変換する単項演算子、最後に、三項演算子。JavaScriptでは三項演算子は `?:` のみ。

JavaScriptでは演算子は必要に応じてオペランドの型を変換する。 `"3" * "5"` も問題なく算術処理を行い、数値の15を返す。オペランドの型で動きが変わる演算子も存在する。＋演算子の場合は左辺値が数値ならば算術、文字列なら連結する。

演算子は優先度が存在し、式の中で優先度を設定するならば()で囲ってやるといい。式は基本的には左から右へ処理されるが、乗演算子、代入演算子、条件演算子は右から左へ処理される。

→追記の必要あり

[4章 式と演算子](#4)  
[目次](#mokuji)  

---

<a id = 5></a>
## ５章 文

JavaScriptにおけるコマンドや文章にあたるもの。セミコロンが文末に記述されることを忘れないこと。

##### 複合文

カンマで区切るなどして複数の式を一文に纏めるように、文ブロックというものを使用すれば複数の文を一つに纏めることができる。文ブロックとは、中括弧で複数のブロックを囲んだもののこと。一つの文しか記述できない場所に文ブロックを配置しても問題はない。

文ブロックには末尾のセミコロンが記述無。ブロック内は読みやすさを考えてインデントするのを推奨。

##### 条件文

条件文に関しては他言語とあまり変わるところはない。いつも通り、 `if/else` が使用される。
基本的には使用方法に違いはないが、 `if/else` の後が単文であるとき、 ｛｝を省略した場合に `else` の動作に特徴がある。

```
// x
if(a = b)
    if(c = d)
        console.log("a = b, c = d");
else
    console.log("a != b");

// o
if(a = b) {
    if(c = d) {
        console.log("a = b, c = d");
    }
} else {
    console.log("a != b");
}
```

インデントにより問題ないように見えるが、上の文章では `else` の部分が `if(c = d)` に対して対応してしまう。括弧で区切ってやれば問題ない。

また、複数の分岐を与える際には `switch` が使用される。それぞれの `case` に対して末尾に `break` を付けるのは、 `case` が実行されるコードの開始点を指定するものであり、終了点を指定しないため。なので `break` が喜寿退れていなければコードブロックの最後まで順に `case` 内の処理を行うことになる。 `switch` は直後の式と `case` ラベルを `===` を使用して比較する。つまりは型変換を行わないということ。

##### ループ文

繰り返し処理を行う文のこと。 `while` `do/while` に関しては他言語と特に変わりはない。 `for` に関してもあまり言うことはないが、個人的には、Cに近い書き方なので見慣れた形に見える。
`for(i = 0; i > 3; ++i)`
`for` の括弧内は左から初期化、条件式（評価式？）、更新（値の）となっていて、これらの文は省略可能になっている（セミコロンは必要なので全て省略した場合は `for(;;)` ）。因みに条件式を省略したときは無限ループになる。

`for/of ` 文は名前にこそ `for` が入っているものの、動作は基本的なループ文と違うものになっている。反復可能であるオブジェクトに対して使用されるものであり、配列や文字列がその主な対象となる。（１２章で追記すべき）配列等の各要素に対して繰り返し処理を行えることだけをとりあえずの理解とする。
```
let data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
for(let hensu of data){
    //本文
}
```
↑のコードでは `data` の要素の数だけ本文が繰り返される。また、本文の実行前に配列の次の要素は `hensu` の中に格納される。

オブジェクトはデフォルトでは反復可能ではないので、通常のオブジェクトに対して `for/of` を使用すると `TypeError` が出力される。

ES6においては文字列は反復可能である。一文字ずつ反復処理され、絵文字などを表す際に実行回数が足りなくなるため、文字コードはUTF-16ではなくUnicodeを利用する。

Mapオブジェクトの場合はキーや値に関して反復処理が行われるわけではなく、キーと値の組み合わせに対して処理が行われる。処理の度、イテレータはキー、値の順で要素が含まれた配列を返す。

→　__*Map*__　:　キーと値を組み合わせてデータを格納できるオブジェクト。配列ではなく、キーは一意である必要がある。
→　**イテレータ**　：　プログラミング言語において配列やそれに類似する集合的データ構造（コレクションあるいはコンテナ）の各要素に対する繰り返し処理の抽象化。JavaScriptにおいては戻り値、終了値の決定を担う。

`for/in` 文は `for/of` 文に似ているが、後者が反復可能なオブジェクトに対応していたのに対して、前者は任意のオブジェクトに対して記述できる。また、指定したオブジェクトのプロパティ名に対して反復処理をする。
```
for(hensu in object)
    //本文
```
`hensu` 部分には基本的に変数を入れるが、宣言や代入式の左辺になり得るものは記述可能。objectは評価するとオブジェクトになるもの。本文は繰り返しされるもの。まず始めに `object` 式を評価して `null` `undefined` の時はループを実行しない。オブジェクトの列挙可能なプロパティ毎に本文を一度ずつ実行する。また、本体の実行前に毎回 `hensu` 部分を評価して `object` のプロパティ名を代入する。

→　オブジェクトの列挙可能なプロパティ　：　そのオブジェクトのプロパティの中で列挙可能（enumerable）フラグが true に設定されているプロパティのこと。基本的な代入や初期化などがこれにあたる。

`for/in` 文の `hensu` 部分には評価した際に代入式の左辺として相応しい値ならばどんな式でも記述可能。実行の旅に評価されるため、その度に違う値を代入することもできる。

配列はオブジェクトの一種。配列のインデックスに関しては変数として扱われるため、出力も可能。注意したいのは、 **配列を扱う場合は `for/in` ではなく `for/of` を使用する点。** 実際、`for/in` はすべてのプロパティが調べられるわけではなく、列挙可能なプロパティが調べられる。

##### ジャンプ文

ジャンプ文は名前通り、実行されたときにソースコード上の別の場所にインタプリタをジャンプさせる文。 `continue` `break` などがこれにあたり、またJavaScriptでは文に **ラベル** を付けることができ、これを付けることでジャンプ文の対象を指定することができる。

ラベル文は、「識別子：本文」の形で任意の文にラベルを付与できる。文にラベルを付けることでプログラム上で他の位置からその文を参照ができる。また、一つの文に複数のラベルを付けることはできるが、二つ以上の文に同一のラベルを付けることはできない。追記しておくと、キーワードの後にラベルを指定することも可能。「キーワード ラベル」のように記述、コロンはいらない。

`break` 文はとても単純なもので、最も内側にあるループを終了させる文。ループや `switch` を終了させるコードなのでそれ以外の場所では使用できない。ラベルを付与した `break` 文は実行されるとラベルで指定したループ等が終了する。注意すべき点は、 **`break` とラベル名の間に改行を挟まないこと** 、改行があるとJavaScriptでは間にセミコロンが省略されていると勘違いしラベルなしの `break` 文を実行しかねない。

`continue` 文は実行された時、次の繰り返しを開始する。 `continue` はループの中でしか使用できない。 `while` `for` で動作が異なる。前者では先頭で指定されている条件式が評価されて本文を実行するか決まり、後者ではループ変数を更新し、本文を実行した後に繰り返すか評価する。 `break` と同様にラベル名との間に空白をいれないこと。

`return` 文は関数本体内でのみ使用でき、基本的に最後に記述される。実行時に直後に記述する値を呼び出し元に返す。以降に文が続いていてもその時点で呼び出し元に戻す。

`yield` 文は `return` 文と似ているが、ジェネレータ関数内でしか使用できず、関数内で使用したときは値を生成して生成順に追加する。（追記すべき）

`throw` 文は例外処理を行うため使用する文。指定した場所に例外を投げる。返す値に型はないので文字列や数値を好きに投げることができる。

`try/catch/finally` 文は、例外処理を行うコードブロックを記述するもの。 `try` 内で先頭から最後までコードを実行し、エラーが発生した場合は `catch` に投げる。 `catch` 内では投げられたエラーを処理したりしなかったりする。 `finally` では `try` が終了した後に実行され諸々の後始末などを行う。

`with`文は指定したオブジェクトのプロパティをそのスコープ中で変数のように扱うもの。
```
with(object)
    //本文
```
オブジェクトのプロパティとして一時的にスコープに追加し、スコープ内で本文を実行する。with文は記述しない方が実行速度が早くなるため非推奨。

`debugger` 文は基本的には何かをする文ではない。デバッガプログラムを使用した場合のみ、デバッグ用の処理を行う場合がある。`debugger` 文はブレークポイントとして使用できる。

`use strict` 文はディレクティブである。ディレクティブは文ではなく、文のようなもの。 `user strict` はこれ以降のコードが厳密（ `strict` ）なコードであることを示している。 `strict` コードは `strict` モード（JavaScript言語の重要な問題点の修正、強力なエラーチェック気候やセキュリティ機構の提供があるモード）で実行される。

[5章 文](#5)  
[目次](#mokuji)  

---

<a id = 6></a>
## ６章 オブジェクト

オブジェクトは複数のデータ値を一つにまとめたもの。名前によってデータを保存、呼び出しが行える。順序のないプロパティの塊。しかし、単に文字列や値をマッピングするだけでなく、オブジェクト自身のプロパティ以外の他のオブジェクトのプロパティを継承することもできる。（？）継承対象を **プロトタイプ** と呼ぶ。このプロトタイプを継承することこそがJavaScriptの特色ともいえる。

オブジェクトは動的であり、プロパティの追加、削除を行うことができる。当然のように、静的なオブジェクトとしてであったり、静的な型の付いた言語の構造体のように扱うこともできる。

オブジェクトは可変かつ、値でなく参照で操作を行うために変数xがとあるオブジェクトを参照しているときに `let y = x;` を実行するとyにはxと同じオブジェクトの参照がされる。間違ってもオブジェクトの内容がyに代入されたり、コピーされているわけではない。また、yでオブジェクトの内容を変更すれば、xで呼び出した際にはyで変更したオブジェクトの内容が呼び出されることになる。

プロパティには名前と値があり、その名前は任意の文字列。空文字でもかまわない。同じ名前のプロパティは複数存在できない。また、値も任意である。対してゲッター、セッターの設定も可能。

JavaScriptではオブジェクトに直接設定されているプロパティと、プロトタイプオブジェクトにから継承されているプロパティを区別するため、継承されていないプロパティを **独自プロパティ** と呼ぶ。そのほかにもプロパティ属性というものを持ち、書き込み可、列挙可、再定義可という属性がある。

##### オブジェクトの生成

オブジェクトの生成にはオブジェクトリテラルを使用するのが最も簡単である。 `{}` の中に `,` 区切りで プロパティ名と値を書き（それぞれの間には `:` ）記述するだけ。
```
const aud = {
    bea_text : "Coral",
    dec_text : "Elf",
};
```
最後のプロパティ後にカンマが入ることはむしろ推奨。追記時に構文エラーになる可能性を減らすことができるため。（書かないとエラーが出たような……はて？）

オブジェクトリテラルは実行されるたびに評価され、オブジェクトが生成されるため、繰り返しの中に記述してしまうとその度にオブジェクトが量産されてしまう。しかもその中身のプロパティの値もそれぞれ異なるものである可能性もあり中々に混沌とする。

`new` 演算子を使用して生成することも可能。 `new` の後ろには呼び出し式を記述すること。
```
let aud = new Object(); // 空のオブジェクトを生成する。
let bea = new Array(); // 新しい配列を生成する。
let cor = new Date(); // 現在時刻を示すオブジェクトを生成する。
let dec = new Map(); // キー/値マッピング用のMapオブジェクトを生成する。
```

`Object.create();` は、第1引数をプロトタイプとする新たなオブジェクトを生成する。
```
let aud = Object.create({bea: 1, cor: 2}); // audはbeaとcorを継承する
aud.bea + aud.cor; // => 3
```
`null` を引数にすると基本的なメソッドすら継承しないため、+演算子すらまともに動作しないオブジェクトになってしまう。空のオブジェクトを生成したい場合は、 `Object.prototype` を引数にすると任意のオブジェクトを継承しているオブジェクトを生成できる。また、オブジェクトに関して意図しない変更を加えないようにする際にも `Object.create()` が使用できる。オブジェクトを継承したオブジェクトを渡すことで変更を防ぐことができる。プロパティを呼び出すと継承された値を出すが、値を設定しても元のオブジェクトは変更されないことになる。
```
let dec = { elf: "Fuen" };
library.function(Object.create(dec)); // ここで変更を防ぐ
```

##### プロトタイプオブジェクトについて

オブジェクトはプロトタイプオブジェクトを継承する。オブジェクトリテラルを用いて生成されたものは全て同じプロトタイプオブジェクトを持つ。これをコード内で `Object.prototype` として参照可。 `new Object();` で生成したオブジェクトに関しても{}で生成したものと同じようにプロトタイプオブジェクトを継承する。 `new Array();` `new Date();` に関しても同じように `Array.prototype` `Date.prototype` を持つ。 `Object.prototype` は例外的に、プロトタイプを持たない。逆に `Date.prototype` 等、他のオブジェクトは `Object.prototype` を継承する通常のオブジェクトとなる。このようなリンク付けられるオブジェクトをプロトタイプチェーンと呼ぶ。

##### プロパティの読み出しと書き込み

プロパティの読み出しにはドット(.)か角括弧([])を使用する。ドットならば右辺に識別子、角括弧ならば括弧内に識別子を記述する。括弧内には文字列か文字列に変換できる値を記述する必要がある。プロパティの作成や呼び出し時には同じように代入式の左辺に記述する。

##### 連想配列として

`Object.property` `Object["property"]` と二つの式は同じ内容を表す。前者の記述方法はCやJavaに近く、構造体やオブジェクトの静的なフィールドにアクセスするものに似ている。後者は配列に対しアクセスするものに似ている。しかし、配列としてはインデックスには数値ではなく文字列をもつ。この配列を連想配列と呼ぶ。（ハッシュ、マップ、辞書とも）JavaScriptのオブジェクトは連想配列である。

強く型付された言語と違い、JavaScriptは制約もなくオブジェクトにプロパティをいくつでも追加することができる。プロパティ使用時は識別子を使用する必要があるが、識別子はJavaScriptのデータ型ではないため文字通りにそのまま記述しなければならない。識別子はプログラム上で操作することは不可。

対して、[]演算子を使用した配列としてのオブジェクトのプロパティを表現する際、プロパティの名前は文字列となる。文字列に関してはデータ型の一つであるため、プログラム上で操作可能かつ、実行中に生成することも可能。配列表記をすることで文字列式で扱うことができ、文字列式でプロパティにアクセスできる。

配列表記でなければ対応できない例として、オブジェクト `bea` に入力される任意のプロパティ名 `cor` とその値 `dec` を設定する際には以下のようになる。
```
function aud(bea, cor, dec) {
    bea[cor] = dec;
}
```
入力されるプロパティ名はコード作成時には予想不可なので `bea` のプロパティを呼び出すために識別子を使用することはできない。というときに[]識別子を利用した方法が役に立つわけである。この演算子では文字列式を使用することができ、静的な識別子と違い、動的な文字列は実行時に変更できる。理解するまでパッとしないように見えたが、存外便利そうだ。
```
function elf(bea) {
    let fue = 0.0;
    for(let gan in bea) {
        let hou = bea[gan];
        let ide = getQuote(gan);
        fue += hou * ide;
    }
    return fue;
}
```
現在ではMapクラスを使った方が簡単らしい。（これまでのは何だったんだ？）

##### 継承

`new` を使用して生成したオブジェクトもプロトタイプオブジェクトからプロパティを継承する。

継承のチェーンについて以下コード。
```
let aud = {}; // prototype継承
aud.x = 1; // 独自プロパティx
let bea = Object.create(aud); //aud継承
bea.y = 2; // 独自プロパティy
let cor = Object.create(bea); //bea継承
cor.z = 3; // 独自プロパティz
let dec = cor.toString(); // toStringはObject.prototypeから継承
aud.x + bea.y;　// => 3; xとyをそれぞれaudとbeaから継承する
```
要するに使いやすいグローバルとローカルの変数のようだと理解。上から下に繋がっている内で、下で呼び出したいプロパティが無ければ上へ遡り対象のプロパティを探査する。という感じか？それぞれのオブジェクト別で独自のプロパティを持つこともできる。ちょっと動きは確かめるべきか？
→ 確かめたところ、間違っていないみたいだ。上から下に探査はできないが、下から上には探査可能。上で設定した変数は共有されるが、下で再設定すると設定箇所以下でその変数が共有され、その上には影響なし。

独自プロパティや継承プロパティに探査の対象になるプロパティが無ければ `undefined` になる。プロパティにおいてはそれで済むが、存在しないオブジェクトに対して参照するとエラーが発生する。つまり、プロパティアクセス式のドットの左辺が `null` `undefined` だとエラーが発生するということ。回避法は下記。
```
// ifでもできるが省略

let aud = bea && bea.cor && bea.cor.dec;
/* 
*  bea.cor.decを取りたいとき、前提となるのは
*  beaとbea.corが定義されているか否か
*  上記は(&&)で真偽を問い、エラーを回避している
*  ((&&)は左辺の真偽を問い、値を返す)
*/ 

let elf = bea?.cor?.dec;
//こちらの方が簡単である。
```

##### プロパティの削除

delete演算子を使用してオブジェクトからプロパティを削除できる。プロパティの値ではなくそれ事態を削除することに加え、独自プロパティを削除するのみである。当たり前のように継承プロパティは削除できない。（上で削除すれば下でも消えるが？）delete演算子は削除時や、削除する必要がなかった時、削除する対象が存在しないときに真を返す。プロパティアクセス式以外に対象を取った時も真を返す。（意味なし）

再定義不可のプロパティに関しては削除できない、組み込みオブジェクトのいくつかのプロパティに関しても再定義は不可なので同じように削除は不許可。

##### プロパティのテスト

纏めるとオブジェクトに特定の名前のプロパティが存在するか否かをテストする。方法としてはin演算子、 `hasOwnProperty()` `propertyIsEnumerable()` を使えばテスト可能。また、単純にプロパティの読み出しでも確認は可能である。プロパティ名は文字列以外に `Symbol` も使用可能。in演算子は `"x" in aud;` の形で真偽を問う。 `hasOwnProperty()` は `o.hasOwnProperty("aud");` で真偽を問う。また、 `propertyIsEnumerable()` は `hasOwnProperty()` の結果を絞り込める。独自プロパティかつ列挙可能である場合にのみ真を返す。特定の組み込みプロパティ以外の生成された通常のプロパティに関しては列挙可能。単純な確かめ方については `aud.x !== undefined;` で真偽を問えば確かめることは可能である。in演算子に限り、存在しないプロパティと存在するが `undefined` に設定されているプロパティを区別できる。

##### オブジェクトプロパティの探査

個別のプロパティを対象にするのではなく、オブジェクト内の全てのプロパティを対象にして一覧を取得したい場合、for/inループで列挙可能なプロパティ毎にループ本体を実行する。ループ本体の実行の際、ループ変数にはプロパティ名が代入されるので云々。コード上で追加したプロパティは列挙可能なので、オブジェクトの継承する組み込みプロパティとは別物。

また、 `for/in` で返されるプロパティの内、継承プロパティに対して処理を行いたくない場合は、以下。
```
// 継承プロパティをスキップ
for(let aud in bea){
    if(!bea.hasOwnProperty(aud)) continue;  
}

// すべてのメソッドをスキップ
for(let aud in bea){
    if(typeof bea[aud] === "function") continue;
}
```
`for/in` を使用するよりも、 `for/of` をオブジェクトのプロパティ名の配列に対して使い、巡回した方がいいこともある。他にも同じようにプロパティ名の配列に対して取得する動作をする関数は以下。
```
Object.keys();
// オブジェクトの列挙可能な独自プロパティの配列を返す
Object.getOwnPropertyNames(); 
// 上に同じ、加えるとプロパティ名が文字列の場合に限り、
// 列挙不可のプロパティも配列に加える
Object.getOwnPropertySymbols();
// プロパティ名がSymbolの独自プロパティの配列を返す。列挙可能か否かは関係ない
Reflect.OwnKeys();
// すべてのプロパティを返す
```

##### プロパティの列挙順序

オブジェクトの独自プロパティを列挙する際に順番が規定されている。

文字列の名前がついたプロパティは名前が非負の整数だと先頭に列挙される。数値として値の小さいものから順に列挙され、配列等はこれにより順序通り列挙されている。

配列等の後には文字列のプロパティを列挙する。順序は追加された順であり、オブジェクトリテラルで定義されていた場合は、記述された順番で列挙される。

最後にSymbolプロパティが列挙される。同じく追加された順序で。

##### 拡張

とあるオブジェクトから、別のオブジェクトへプロパティをコピーできる。コードは以下。
```
let aud = {x: 1}, bea = {y: 2, z: 3};
for(let cor of Object.keys(bea)) {
    aud[cor] = bea[cor];
}
aud; // => {x: 1, y: 2, z: 3}
```
一般にコピー処理を行うユーティリティ関数を `extend()` と呼んでいたが、ES6になり、コアJavaScript言語に `Object.assign()` が追加された。これは引数を複数取り、2つ目以降の引数をコピー元とする。コピー元のオブジェクトは変更されず、列挙可能な独自プロパティをコピー先にコピーする。引数に記述された順に処理は行われる。（追記すべき）

##### シリアライズ

シリアライズ（直列化）とは、オブジェクトを再度同じオブジェクトに戻せるような文字列に変換すること。変換には `JSON.stringfy()` 戻すには `JSON.parse()` という関数が用意されている。JSONとは、JavaScript Object Notationの略。

##### 汎用的メソッド

Object.prototypeで定義されている汎用的なメソッドについて。

toString()メソッドは、呼び出したオブジェクトの文字列を返す。引数を取らず、JavaScript側で文字列に変換する必要があると判断するとこのメソッドを呼び出す。デフォルトでは役立たずなので、多くのクラスで独自に設定されている。

toLocaleString()メソッドは、全てのオブジェクトに定義され、オブジェクトを表すローカライズされた文字列を返す。デフォルトではtoString()を呼び出すだけのもの。何もローカライズされない。

valueOf()メソッドは、toString()メソッドと同じように使われ、文字列以外の基本型に変換する必要があると判断されたとき、JavaScriptが呼び出す。デフォルトでは特殊なことは行わないが、Dateクラス等では独自に設定がされており、日付を数値に変換したりする。

##### 拡張構文

簡略記法として、以下コード。
```
let aud = 1, bea = 2;
let cor = {aud, bea};
cor.aud + cor.bea; // => 3
```
##### 算出プロパティ

特定のプロパティを持つオブジェクトを生成するとき、そのプロパティ名が定数でなく変数に保存されている、関数の戻り値である等、コンパイル時に決定されていないときにオブジェクトを生成、必要なプロパティの追加処理を行う必要がある。

それを容易にするのが算出プロパティである。角括弧内でJavaScript式を記述し、その式の評価結果がプロパティ名になる。例えば、特定のライブラリの中で定義されているプロパティ名を引数に設定すると算出プロパティが利用される。プロパティ名を間違える等のバグを防ぐために、ライブラリで定義されているプロパティ名定数を使用して算出プロパティを動作させることでコードの安全性を保てる。（追記すべき）

##### Symbolプロパティ

Symbolは不透明な値であるためプロパティ名に使用できるだけで他には何もできない。しかし、他のものと違う一意なプロパティ名を生成したい場合は有用である。確実に異なるプロパティ名を生成できるので安全にオブジェクトを拡張することが可能になる。また、Symbolでプロパティ名を設定すれば、誤ってプロパティを変更してしまうようなこともあり得ないのでより安全。（削除変更が出来ないわけではないので、セキュリティ上の安全のためではない。あくまで開発上での安全性のお話）

##### スプレッド演算子

スプレッド演算子(...)を使用すれば既存のオブジェクトのプロパティを新しいオブジェクトにコピーできる。

実際には演算子ではなく、特殊な構文。他の場面では、(...)は別の目的で使用されている。スプレッド演算子は書くことは容易だが、オブジェクトの有するプロパティの数が増えるほど処理の量は膨大になるため注意する必要がある。

##### メソッドについて

関数がプロパティとして定義された場合、それをメソッドと呼ぶ。以前まではオブジェクトリテラル内で `aud: function() {return this.bea},` 等の形で書く必要があったが、ES6以降では `function` やコロンは省略され、 `aud() {return this.bea},` のような形で記述できるようになった。

上記のようなデータプロパティの他にも、アクセサプロパティに関してもサポートしている。ゲッターとセッターの両方か一方をもつプロパティのことで、読みだすと引数なしでゲッターを呼び出し、戻り値をプロパティアクセス式の値とする。値を設定すればセッターが呼び出されプロパティ値の設定に対し責任が生まれる。また、戻り値に関しては無視される。

ゲッターとセッターの両方をもつプロパティは読み書き可能、ゲッターのみならば読み出し専用、セッターのみならば書き込み専用となるわけである。また、書き込み専用プロパティを呼び出すと `undefined` が出力される。

[6章 オブジェクト](#6)   
[目次](#mokuji)  

---

<a id = 7></a>
## ７章 配列

配列とは、ご存じの通り値を順序付けてまとめたもの。値自体はその配列の要素と呼ぶ。各要素に紐づけられた番号をインデックスという。JavaScriptでは配列に型がない。インデックスは0から始まる、32ビットの整数であり、動的であるため、配列の長さを指定する必要はない。また、JavaScriptでは配列は疎であって問題ない。つまりは最初から最後まで要素が連続する必要はない。JavaScriptの配列は全てが `length` を持っており、疎でなければ配列の要素数、疎ならばインデックス中の最大値よりも大きなものが降られる。JavaScriptにおいて配列はオブジェクトの特別な形式だとされている。

配列は `Array.prototype` からプロパティを継承する。汎用的なメソッドが多く実装されているので配列の操作は多岐にわたる。

ES6からは、型付き配列が実装。数値型かつ固定の長さを持ち、バイナリデータを高速処理、バイト単位でのアクセス可能だったりする。

##### 配列の生成

配列リテラルは配列を生成する方法の中では最も単純で優しく見える。角括弧の中をカンマ区切りで記述するのみ。
```
let aud = [bea, cor, dec];
```
配列リテラルには定数以外にも任意の式やオブジェクトリテラル、他の配列リテラルも記述できる、また、値なしでカンマを連続で記述すると、配列は疎であると扱われる。該当箇所の配列の要素は存在せず、返す値は `undefined` になる。末尾のカンマは許可されていることは忘れる必要がない。

スプレッド演算子を使用することで配列リテラル内に別の配列の要素を加えることもできる。
```
let elf = [fue, ...aud, gan];
elf; // => [fue, bea, cor, dec, gan]
```
配列リテラル内でスプレッド演算子後の配列が展開される。配列のコピーに便利。

（スプレッド演算子は演算子じゃない。という話が繰り返されるが、場所によっては(...)という表記で別の動作をすることがあるので、配列リテラル内と関数呼び出し時のみのこの動作をするものをスプレッド演算子と呼ぶ。）← これいる？

スプレッド演算子は反復可能ばオブジェクトに対して動作するので文字列等は反復可能であるため、任意の文字列を一文字ずつ配列の要素に変換できる。

##### Array()コンストラクタ

Array()コンストラクタでも配列の生成は可能である。
```
let aud = new Array();
```
→ 引数なしで呼び出すと要素のない空の配列が生成される。
```
let aud = new Array(10);
```
→ 引数を一つだけ指定すると、引数は配列の長さとされて配列は生成される。必要な要素数がわかっている場合は有用である。また、要素内は空。
```
let aud = new Array(5, 4, 3, 2, 1);
```
→ 引数が複数になるか、数値以外だと引数は配列の要素とされて配列は生成される。

##### Array.of()

Array()コンストラクタでは要素が一つだけの配列を生成することができない。ES6以降ではArray.of()により、この問題は解決されている。

##### Array.from()

第1引数として配列のようなオブジェクトを指定することでオブジェクトの要素を含む新たな配列を生成できる。また、反復可能なオブジェクトを指定すると `Array.from(iterable)` はスプレッド演算子を使用した `[...iterable]` と記述した時と同じ動作をする。

配列のような、長さを持ち、プロパティに整数値を持った非配列オブジェクトを普通の配列に変換することができる点が優秀。

オプションで第2引数に関数を指定すると、コピー元のオブジェクト毎に関数は呼び出される。この関数の戻り値が配列中に格納される。

##### 配列におけるメソッド

イテレータメソッドは配列をループして、配列の要素を順番に指定した関数に渡すもの。配列の反復処理やマッピング、フィルタリング、テスト、集約を行うときに便利。共通することとして、第1引数として関数を受け取り、関数を要素毎か、いくつかの要素に対し、一度ずつ呼び出される。配列が疎である場合、存在しない要素に関数は呼び出されることはない。

大抵、関数には引数が3つは渡されて呼び出されることになる。配列要素の値、配列要素のインデックス、配列そのもの。この内、第1引数にあたるものが必要となることが多い。

イテレータメソッドの多くは第2引数を渡すことができる。関数が呼び出される際に、第2引数のメソッドとして呼び出されることになる。つまり、第1引数の指定した関数内で、第2引数が `this` が示すものになる。

第1引数に指定する関数は他の場所で定義するのではなく、多くの場合は式の中でアロー関数を用いて定義される。

**forEach()メソッド** は、配列を循環し、要素毎に指定された関数を呼び出す。第1引数に関数を指定し、実際には引数を3つ渡す。配列要素の値以外はほとんどの場合無視され、記述されることもない。また、このメソッドはすべての要素が関数に渡される時まで止まることはない。 `break` に類するものさえ存在しない。

**map()メソッド** は配列の要素を1つずつ指定した関数に引数として渡し、返された値を配列に格納、そして配列を返す。元の配列と同じ長さの、同じインデックス要素の存在しない新しい配列を生成するメソッド。呼び出し元の配列が疎ならば返す配列も疎である。

**fillter()メソッド** は、配列の要素の部分集合となる配列を返す。メソッドに指定した関数は述語になり、この述語関数は他メソッドと同じように呼び出される。述語関数の戻り値が `true` `false` になるようなものならば、述語関数に渡された各要素は戻り値の配列に追加される。元の配列が疎ならば、存在しない要素は飛ばして処理するので、返る配列は密になる。
疎配列を密配列に直すコードは以下。
`let aud = sparse.fillter(() => true);` 
`undefined` `null` の要素を取り除くコードは以下。
`bea = bea.fillter(x => x !== undefined && !== null);`

**find()、findIndex()メソッド** はfillter()メソッドと同じような処理を行う。指定した述語関数が `true` に変換される値を返す要素を探し巡回する。異なるのは述語関数を発見した時点で巡回を中止し、find()は見つけた要素を返し、findIndex()は見つけた要素のインデックスを返す。要素が見つからなければそれぞれ、find()、findIndex()。

**every()メソッド** は配列の全ての要素に対し、指定した述語関数が `true` を返した場合に `true` を返す。 `false` が返り値になった段階で巡回を終える。

**some()メソッド** は配列の中の少なくとも一つの要素に対して指定した述語関数が `true` を返した場合に `true` を返す。`true` が返り値に確定した時点で巡回を終える。

**reduce()メソッド** は引数を二つ指定する。第一引数として簡約化（二つの値を組み合わせて一つの値にする）を行う関数を指定する。また、第二引数は省略可、指定するとその値を初期値とする。メソッド内の関数は配列を二、三、四番目と引数とし、最後の引数に簡約化した結果を返す。最初の引き出し時には指定した第二引数、初期値が呼び出される。

**flat()メソッド** は呼び出し元の配列と同じ要素を持つ配列を生成し、返す。元の配列から一階層展開して返す（フラット化）。引数を指定すればその分展開、引数無なら一階層展開。

**flattype()メソッド** はMap()とほぼ同じだが、返される配列が自動で展開される違いがある。Map()をフラット化して任意の要素へとマップできるようにする。

**concat()メソッド** は配列を結合できる。呼び出し元の配列に()内の記述で要素を追加することもできる。また、concat()では呼び出し元の配列を変更することはなく、呼び出し元の配列の新しいコピーを生成する。

**push()メソッド** はスタックと同じように、配列の最後に一個以上の要素を追加し、追加した後の配列の長さを返す。

**pop()メソッド** はpush()の逆で、最後の要素を削除して配列の長さを小さくしたうえで削除した要素の値を返す。

**shift()メソッド** は配列の先頭を削除し、削除した要素を返す。そして削除した場所へ後続の要素をずらす。

**unshift()メソッド** は先頭に一個以上の要素を追加し、既存よりも大きなインデックス番号の配列へ要素をずらし、新しい配列の長さを返す。

**slice()メソッド** は指定された配列のサブ配列（スライス）を返す。返すスライスの先頭を第一引数、末尾を第二引数で指定できる（末尾に指定した要素は含まない）。また、呼び出し元の配列を変更しない。

**splice()メソッド** は配列に要素を挿入、削除と基本的で汎用的な配列の操作を行うことができる。呼び出し元の配列を変更する。挿入と削除は同時に行うことができ、第一引数に操作したい要素の先頭、第二引数には末尾を指定できる。また、第二引数を指定しないと指定した場所から先、末尾までを削除する。そして削除した要素の配列を返す。

**fill()メソッド** は配列要素または配列のスライスを指定した値に設定する。呼び出した配列を変更し、変更した配列を返す。第一引数には配列の要素に設定する値を指定し、第二引数は開始位置のインデックスを記述する。第二引数は省略すると0から開始される。また、第三引数には終了位置のインデックスを記述。省略すると配列の末尾まで処理を行う。負数を指定すると末尾からの相対位置まで、と指定できる。

**copyWithinメソッド** は配列のスライスを配列内に新しくコピーすることができる。呼び出し元の配列を変更し、変更した配列を返す。第一引数にペースト先、第二引数にコピーの開始位置、第三引数に終了位置を指定できる。省略時は他と同じ。

##### 配列の検索メソッドとソートメソッド

配列は文字列と同じように `indexOf()` `lastIndexOf()` `inclides()` メソッドが実装されている。また要素を入れ替える `sort()` メソッドと `reverse()` メソッドもある。

**indexOf()メソッド** と **lastIndexOf()メソッド** は配列中から指定した要素を探し、該当するインデックスを返す。前者は配列の先頭から、後者は配列の末尾から検索を行う。検索時、引数と要素の比較には `===` と同じ処理を行う。配列の要素がオブジェクトの時は、引数と同じオブジェクトを参照しているかを確認する。オブジェクトの内容で検索したい場合は `find()` を使用する。また第二引数を指定した場合は、指定したインデックスから配列を検索する。

**includes()メソッド** は引数を一つとり、配列中に引数と同じ値があるのなら `true` を返す。含まれていない場合は当然 `false` を返す。配列中に引数と同じ値があるか、を返すのみなのでインデックスを返したりはしない。

**sort()メソッド** は配列の要素をソードするときに使用するもの。新しい配列を生成するのではなく、呼び出し元の配列をソートして、ソート後の配列を返す。第一引数に指定がなければ、アルファベット順（必要に応じ要素を文字列とみなす）にして返す。また、要素に `undefined` が含まれる場合は、末尾にソートされる。アルファベット順以外を指定したい場合は引数に比較関数を指定、比較関数の二つの引数を比較する？？？
```
let a = [1, 2, 3, 4, 5];
a.sort(); // => (5) [1, 2, 3, 4, 5]
a.sort(function(a,b){
    return a-b;
}); // => (5) [1, 2, 3, 4, 5]
a.sort((a,b) => b-a); // => (5) [5, 4, 3, 2, 1]
```
実際に試してみるとわかりやすい。

**reverse()メソッド** は配列の要素の順番を逆にする。呼び出し元の配列を逆順に変更する。並べ替えたものを返す。

##### 配列から文字列への変換

Arrayクラスには、配列を文字列に変換するメソッドが三つある。基本的にログやエラーメッセージの作成で使用する。

**join()メソッド** は配列のすべての要素を文字列に変換して結合し、連結した文字列を返す。各要素を区切る文字の指定も可能になっている。引数で指定するが、省略するとカンマ区切りになる。
```
let a = [1, 2, 3, 4, 5];
a.join(); // => "1,2,3,4,5"
```
逆に文字列を配列にするならば `String.split()` がある。

**toString()メソッド** は引数を指定せずに実行した `join()` 、つまりカンマ区切りの文字列を返す。

##### 配列の静的関数

**Array.isArray()** は引数にとったものが配列か調べるメソッド。

##### 配列のようなオブジェクト

JavaScriptのオブジェクトは普通のオブジェクトと違う特別な機能が存在する。

- 配列に要素を追加すると自動でlengthが更新される。
- lengthに現在の長さよりも小さな値を設定すると、配列を縮めることができる。
- 配列はArray.prototypeから便利なメソッドを継承する。
- Array.isArray()は配列に対してtrueを返す。

以上がJavaScriptのオブジェクト固有の特徴。

##### 配列としての文字列

JavaScriptの文字列はUTF-16形式のUnicode文字の読み出し専用配列のように動作する。文字列の個々の文字にアクセスするため `charAt()` メソッドを使えるが、代替として `[]` を使用できる。角括弧のほうがコード的にはスマートに見えるかもしれない。また、文字列は不変であるため、配列として扱う以上は読み出し専用の配列である。

[7章 配列](#7)  
[目次](#mokuji)  

---

<a id = 8></a>
## ８章 関数